## `함수`

### 스코프란?

스코프는 한글로 번역시 '범위'라는 뜻을 가지고 있다.

즉 스코프란 '변수에 접근할 수 있는 범위'라고 할 수 있다.

<br />

### `스코프에 종류`

자바스크립트에서 스코프는 2가지 타입이 있다.

전역 스코프와 지역 스코프이다.

<br />

#### `전역 스코프(Global Scope)`

전역에 선언되어있어 어느 곳에서든 해당 변수에 접근할 수 있다.

#### `지역 스코프(Local Scope)`

해당 지역에서만 접근할 수 있고 지역을 벗어난 곳에선 접근할 수 없다.

여담으로 자바스크립트에서 함수를 선언하면 함수를 선언할 떄마다 새로운 스코프를 생성하게 되는데

함수 몸체에 선언한 변수는 해당 함수 몸체 안에서만 접근할 수 있다. 이것을 함수 스코프(function-scoped)라고 한다.

함수 스코프가 지역 스코프의 예시라고 할 수 있다.

<br />

### 렉시컬 스코프란?

함수를 어디서 호출하는지가 아니라 어디에 선언하였는지에 따라 결정되는 것을 말한다.

즉 함수를 어디서 선언하였는지에 따라 상위 스코프를 결정한다는 뜻이며, 가장 중요한 점은 함수의 호출이 아니라

함수의 선언에 따라 결정된다는 점이다. 다른 말로 정적 스코프(static scope)라고 부르기도 한다.

여담으로 클로저를 이해하기 위해서는 반드시 렉시컬 스코프를 이해해야 한다.

<br />

아래 코드가 어떻게 동작할지 생각해보자.

```
var my_number = 1;

const first_func = () => {
  var my_number = 10;
  second_func();
}

const second_func = () => {
  console.log(my_number);
}

first_func();
second_func();
```

<br />

출력 값으로 10과 1이 출력될 줄 알았지만 실제 결과에서는 전역에 있는

변수 my_number의 값 1이 두 번 출력되었다.

<br />

![image](https://user-images.githubusercontent.com/94499416/208807808-20943b2f-1c88-482b-a719-ce4698778bc7.png)

<br />

이러한 이유는 자바스크립트에서 위와 같은 코드를 작성할 때, 이미 실행 단계에서 코드들의 스코프를 결정한다.

- global 범위에 있는 변수 X
- first_func() 함수 안에 있는 변수 X
- second_func() 함수 안에 있는 변수 X

위 예제의 실행 결과는 함수 second_func()의 상위 스코프가 무엇인지에 따라 결정된다.

자바스크립트는 렉시컬 스코프를 따르므로 함수를 선언한 시점에 상위 스코프가 결정된다.

**즉 이말은 함수를 어디에서 호출하였는지는 스코프 결정에 아무런 의미를 주지 않는다는 말이다.**

그렇기 떄문에, second_func() 함수가 first_func() 함수 안에서 호출된 것과 상관없이 second_func() 함수는 global 범위에 선언되어

있으므로, global 범위에 있는 변수 x의 값 1이 두 번 출력된 것이다.

<br />

### 전역 변수로 변수를 선언하면 생기는 문제점은?

- 암묵적 결합
  - 전역 변수는 모든 코드가 전역 변수를 참조하고 변경할 수 있는 암무적 결합을 허용한다. 즉 유효 범위가 크면 코드의 가독성이 나빠지고
    의도치 않게 상태가 변경되어 위험성이 높아진다.
- 긴 생명 주기
  - 긴 생명 주기로 인해 메모리 리소스도 오랜 기간 소비하고, 상태 변경에 의한 오류가 발생할 확률이 높다.
- 스코프 체인 상에서 종점에 존재
  - 스코프 체인 상에서 종점에 존재하기 때문에 가장 마지막에 검색된다. 즉 검색 속도가 가장 느리다. 라는 것이다.
- 네임스페이스 오염
  - 자바스크립트의 문제 중 하나는 파일이 분리되어 있다 해도 전역 스코프를 공유한다. 따라서 다른 파일 내에서 동일한 이름으로
    전역 변수나 전역 함수를 재 할당하는 경우 예상치 못한 결과를 가져올 수 있다.
