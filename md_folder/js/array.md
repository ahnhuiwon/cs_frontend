## `배열`

### `자바스크립트의 배열은 자료구조의 배열과 같은가?`

결론적으로 말하자면, 자바스크립트의 배열은 배열이 아닌 객체이다. 

더 정확하게는 일반적인 배열의 동작을 흉내 낸 특수한 객체이다.

한번 자세히 알아보자.
  
<br />

#### `자료구조의 배열`

자료구조에서 말하는 배열은 동일한 크기의 메모리 공간이 빈틈없이 연속된 나열된 자료구조이다.

우리가 통상적으로 알고 있는 이 배열을 밀집 배열(dense array)라고 한다.

<br />

![image](https://user-images.githubusercontent.com/94499416/204695253-e3e8af0c-2d3b-40eb-817d-e6af22deefaa.png)

<br />

위 그림과 같이 일반적인 배열은 각 요소가 동일한 데이터 크기를 가지며, 빈틈없이 연속적으로 이어져 있다.

<br />

#### `자바스크립트의 배열`

자바스크립트에서 배열은 요소를 위한 각각의 메모리 공간은 동일한 크기를 갖지 않아도 되며,

연속적으로 이어져 있지 않을 수도 있다. 이러한 배열을 희소 배열(sparse array)라고 한다.

<br />

```
const my_array = [1,2,3];

console.log(typeof my_array); //  Object
console.log(my_array.constructor === Array);  //  true
console.log(Object.getPrototypeOf(my_array) === Array.prototype); //  true
```

<br />

위 코드의 console를 보면 자바스크립트에서의 배열은 객체이다.

그렇다면 일반 객체와는 어떠한 차이점이 있을까?

<br />

|구분|객체|배열|
|------|---|---|
|구조|프로퍼티 키와 값|인덱스와 요소|
|값 참조|프로퍼티 키|인덱스|
|값 순서|X|O|
|length 프로퍼티|X|O|

<br />

일반 객체와 배열을 구분하는 가장 명확한 차이는 값의 순서와 length 프로퍼티의 유무이다.

아래의 코드를 확인해보자.

```
console.log(Object.getOwnPropertyDescriptors([1, 2, 3]));
```

<br />

이 코드는 다음과 같은 결과를 출력한다.

<br />

![image](https://user-images.githubusercontent.com/94499416/204696537-f8ef1186-abe0-43cb-ae6b-654874254bad.png)

<br />

자바스크립트 배열은 인덱스를 나타내는 문자열을 프로퍼티 key로 가지며, length 프로퍼티를 갖는 특수한 객체이다.

자바스크립트 배열의 요소는 사실 value 값인것이다.

자바스크립트에서는 모든 값이 객체의 프로퍼티 값이 될 수 있으므로 어떠한 타입의 값이라도 배열의 요소가 될 수 있다.

- 일반적인 배열
  - 인덱스로 요소에 빠르게 접근 가능
  - 특정 요소를 검색하거나 삽입 또는 삭제의 경우 효율적이지 못함
- 자바스크립트의 배열
  - 해시 테이블로 구현된 객체로 인덱스로 요소에 접근하는 경우 일반적인 배열보다 성능적으로 느림
  - 특정 요소를 검색하거나 삽입 또는 삭제하는 경우에는 일반적인 배열보다 성능적으로 빠름

<br />

### `배열의 메서드의 종류`

- sort
  - 배열을 오름차순 내림차순으로 정렬
- join
  - 배열을 문자열로 변환
- split
  - 문자열을 배열로 변환
- reverse
  - 배열의 아이템 순서를 뒤집는다
- splice
  - 인덱스로 배열의 아이템을 삭제
  - 인덱스로 배열의 아이템을 여러개 삭제
  - 인덱스로 배열의 아이템을 삭제하고 해당 인덱스에 새로운 아이템을 추가
- slice
  - 배열의 특정한 부분을 리턴
- find
  - 배열의 모든 요소들을 돌면서 전달한 콜백함수의 인자로 넣고 호출
  - 콜백 함수의 반환된 값이 true이면 그 즉시 멈추고 해당 요소를 리턴
- filter
  - 배열의 모든 요소들을 돌면서 전달한 콜백함수의 인자로 넣고 호출
  - 콜백 함수의 반환된 값이 true인 요소들을 모아 새로운 배열을 만들어서 리턴
- map
  - 배열의 모든 요소들을 돌면서 전달한 콜백함수의 인자로 넣고 호출
  - 콜백함수의 반환된 값들을 모두 요소로 담아서 새로운 배열을 리턴
- some
  - 배열의 모든 요소들을 돌면서 전달한 콜백함수의 인자로 넣어 호출
  - 콜백함수의 결과가 하나라도 true가 있으면 true를 반환
- every
  - 배열의 모든 요소들을 돌면서 전달한 콜백함수의 인자로 넣어 호출
  - 콜백함수의 결과가 모두 true일때만 true를 반환
- reduce 
  - 원하는 시작점부터 모든 배열의 요소들을 돌면서 어떤 값을 누적할 때 사용
- reduceRight 
  - 배열의 제일 뒤(오른쪽)부터 시작하여 모든 배열의 요소를 돌면선 어떤 값을 누적

<br />

### `고차 함수란?`

함수를 매개변수(parameter)로 사용하거나 함수를 반환하는 함수이다.

쉽게 설명한다면 사용하는 함수가 함수를 인자로 받아서 사용하거나 결과 값으로 함수를 반환하게 한다면

고차 함수라는 이야기이다.

<br />

#### `함수를 매개변수로 사용하는 함수`

```
const example_function = (param) => {
  setTimeout(()=>{
    param();
  }, 3000);
};

example_function(()=>{ console.log(1) });
example_function(()=>{ console.log(2) });
```

<br />

이 코드는 특정 기능이 바로 동작하지 않고 3초 뒤에 시작하는 함수이다.

example_function 함수는 인자로 함수를 전달받고 setTimeout()를 통해 3초 후 전달받은 함수를 실행한다.

<br />

#### `함수를 반환하는 함수`

<br />

```
const outer_func = (name) => {
  const out_put = 'Hello ' + name + ' !';
  
  return ()=>{
    alert(out_put);
  }
}

outer_func('james')();
```

<br />

### `forEach 메서드와 map메서드의 차이점은?`

두 함수 모두 **함수형 프로그래밍**을 위한 메소드이다.

함수형 프로그래밍은 순수 함수와 보조 함수의 조합을 통해 로직 내에 존재하는 조건문과 반복문을 제거하여

복잡성을 해결하고 변수의 사용을 억제하여 상태 변경을 피하려는 프로그래밍 패러다임이다.

<br />

#### `forEach`

forEach 메소드는 내부에서 반복문을 통해 자신을 호출한 배열을 순회하면서 수행해야할 처리를

콜백 함수로 전달받아 반복 호출한다.

forEach 메소드는 원본 배열을 변경하지 않고 반환값은 언제나 undefined이다.

```
const my_array = [1,2,3];
const after_array = [];
my_array.forEach(x=>after_array.push(x=>x**2));
console.log(powers); //[1,4,9]
```

#### `map`

map 메소드는 자신을 호출한 배열의 모든 요소를 순회하면서 인수로 전달받은 콜백 함수를 반복 호출한다.

하지만 forEach와는 달리 콜백 함수의 반환값들로 구성된 새로운 배열을 반환한다.

원본 배열은 변경하지 않으며 원본 배열의 원소와 일대일 맵핑이 진행되기 때문에 원본 배열과

맵핑 후의 배열 길이는 항상 같다.

```
const my_number = [1,2,3];
const after_array = my_number.map(x=>x*2);
console.log(after_array) // [2,4,6];
```
